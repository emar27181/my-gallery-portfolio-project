---
import { images } from '../data/image';
const breakpointCols = { default: 4, 1024: 3, 768: 2, 640: 2 };

// Get unique tags from all images
const allTags = [...new Set(images.flatMap(image => image.tags))];
---

<div class="gallery-container">

  <!-- ğŸ·ï¸ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ & ã‚½ãƒ¼ãƒˆ -->
  <div class="controls-container">
    <div class="filter-container">
      <label for="filter-tags" class="filter-label">ãƒ•ã‚£ãƒ«ã‚¿:</label>
      <div class="filter-tags-container">
        <div class="filter-tags" id="filter-tags">
          <span class="filter-placeholder">ã‚¿ã‚°ã‚’é¸æŠã—ã¦ãã ã•ã„</span>
        </div>
        <div class="filter-dropdown" id="filter-dropdown">
          <div class="filter-option" data-value="all">å…¨ã¦</div>
          {allTags.map(tag => (
            <div class="filter-option" data-value={tag}>{tag}</div>
          ))}
        </div>
      </div>
    </div>
    
    <!-- ä¸¦ã³æ›¿ãˆæ©Ÿèƒ½ã¯ä¸€æ™‚çš„ã«éè¡¨ç¤º -->
    <!--
    <div class="sort-container">
      <label for="sort-select" class="sort-label">ä¸¦ã³é †:</label>
      <select id="sort-select" class="sort-select">
        <option value="custom">ã‚«ã‚¹ã‚¿ãƒ é †</option>
        <option value="date-desc">æ—¥ä»˜ (æ–°ã—ã„é †)</option>
        <option value="date-asc">æ—¥ä»˜ (å¤ã„é †)</option>
        <option value="title-asc">ã‚¿ã‚¤ãƒˆãƒ« (ã‚-ã‚“)</option>
        <option value="title-desc">ã‚¿ã‚¤ãƒˆãƒ« (ã‚“-ã‚)</option>
        <option value="category">ã‚«ãƒ†ã‚´ãƒª</option>
      </select>
    </div>
    -->
  </div>

  <!-- ğŸ–¼ ã‚®ãƒ£ãƒ©ãƒªãƒ¼ -->
  <div id="gallery" class="masonry-grid">
    {
      images.map(({ src, alt, title, tags, date }, index) => (
        <div class="masonry-item" data-tags={tags.join(',')} data-title={title} data-date={date} data-category={tags[0]} data-index={index}>
          <img
            src={src}
            alt={alt}
            title={title}
            class="mb-[4px] block h-auto w-full rounded-lg cursor-pointer hover:opacity-90 transition-opacity duration-200"
            loading="lazy"
            data-src={src}
            data-alt={alt}
            data-title={title}
          />
        </div>
      ))
    }
  </div>
</div>

<!-- Image Modal -->
<div class="image-modal" id="image-modal">
  <div class="image-modal-overlay" id="image-modal-overlay">
    <div class="image-modal-content">
      <img class="image-modal-img" id="image-modal-img" src="" alt="" />
      <button class="image-modal-close" id="image-modal-close" aria-label="Close image">
        <svg fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
        </svg>
      </button>
    </div>
  </div>
</div>

<script>
  let currentFilter = [];
  let currentSort = 'custom';
  let selectedTags = [];
  
  function sortGallery(sortBy) {
    const galleryContainer = document.getElementById('gallery');
    const items = Array.from(document.querySelectorAll('.masonry-item'));
    
    items.sort((a, b) => {
      switch (sortBy) {
        case 'custom':
          return parseInt(a.getAttribute('data-index')) - parseInt(b.getAttribute('data-index'));
        case 'date-desc':
          return new Date(b.getAttribute('data-date')) - new Date(a.getAttribute('data-date'));
        case 'date-asc':
          return new Date(a.getAttribute('data-date')) - new Date(b.getAttribute('data-date'));
        case 'title-asc':
          return a.getAttribute('data-title').localeCompare(b.getAttribute('data-title'));
        case 'title-desc':
          return b.getAttribute('data-title').localeCompare(a.getAttribute('data-title'));
        case 'category':
          const categoryA = a.getAttribute('data-category');
          const categoryB = b.getAttribute('data-category');
          if (categoryA === categoryB) {
            // Secondary sort by date if categories are the same
            return new Date(b.getAttribute('data-date')) - new Date(a.getAttribute('data-date'));
          }
          return categoryA.localeCompare(categoryB);
        default:
          return 0;
      }
    });
    
    // Clear container and re-append sorted items
    galleryContainer.innerHTML = '';
    items.forEach(item => {
      galleryContainer.appendChild(item);
    });
    
    currentSort = sortBy;
    
    // Re-apply current filter after sorting
    filterGallery(currentFilter);
    
    // Re-initialize masonry layout
    initMasonryLayout();
  }
  
  function filterGallery(selectedTags) {
    const masonryItems = document.querySelectorAll('.masonry-item');
    
    masonryItems.forEach(item => {
      const itemTags = item.getAttribute('data-tags').split(',');
      
      if (selectedTags.length === 0 || selectedTags.includes('all')) {
        item.style.display = 'block';
      } else {
        // Check if item has ALL selected tags
        const hasAllTags = selectedTags.every(tag => itemTags.includes(tag));
        item.style.display = hasAllTags ? 'block' : 'none';
      }
    });
    
    currentFilter = selectedTags;
    
    // Re-initialize masonry layout after filter changes
    setTimeout(() => initMasonryLayout(), 10);
  }
  
  // Masonry layout initialization
  function initMasonryLayout() {
    const gallery = document.getElementById('gallery');
    if (!gallery) return;
    
    const items = Array.from(gallery.querySelectorAll('.masonry-item')).filter(item => 
      item.style.display !== 'none'
    );
    
    // Get current column count based on screen width
    const screenWidth = window.innerWidth;
    let columnCount = 4; // default
    if (screenWidth <= 640) columnCount = 2;
    else if (screenWidth <= 768) columnCount = 2;
    else if (screenWidth <= 1024) columnCount = 3;
    
    // Create column arrays
    const columns = Array.from({ length: columnCount }, () => []);
    const columnHeights = Array.from({ length: columnCount }, () => 0);
    
    // Distribute items to columns
    items.forEach(item => {
      const shortestColumnIndex = columnHeights.indexOf(Math.min(...columnHeights));
      columns[shortestColumnIndex].push(item);
      
      // Estimate height (will be refined after images load)
      const img = item.querySelector('img');
      if (img && img.naturalHeight > 0) {
        const aspectRatio = img.naturalWidth / img.naturalHeight;
        const itemWidth = gallery.offsetWidth / columnCount - 8; // account for gaps
        const estimatedHeight = itemWidth / aspectRatio + 4; // account for margin
        columnHeights[shortestColumnIndex] += estimatedHeight;
      } else {
        columnHeights[shortestColumnIndex] += 200; // fallback height
      }
    });
    
    // Clear and rebuild gallery
    gallery.innerHTML = '';
    gallery.style.display = 'flex';
    gallery.style.gap = '8px';
    
    // Create column containers
    columns.forEach((columnItems, index) => {
      const columnDiv = document.createElement('div');
      columnDiv.className = 'masonry-column';
      columnDiv.style.flex = '1';
      columnDiv.style.display = 'flex';
      columnDiv.style.flexDirection = 'column';
      columnDiv.style.gap = '4px';
      
      columnItems.forEach(item => {
        columnDiv.appendChild(item);
      });
      
      gallery.appendChild(columnDiv);
    });
  }
  
  document.addEventListener('DOMContentLoaded', () => {
    // Initialize masonry layout
    initMasonryLayout();
    
    // Initialize with default sort
    sortGallery(currentSort);
    
    // Multi-tag filter functionality
    const filterTags = document.getElementById('filter-tags');
    const filterDropdown = document.getElementById('filter-dropdown');
    const filterOptions = document.querySelectorAll('.filter-option');
    
    // Toggle dropdown
    if (filterTags) {
      filterTags.addEventListener('click', () => {
        filterDropdown.classList.toggle('open');
      });
    }
    
    // Handle tag selection
    filterOptions.forEach(option => {
      option.addEventListener('click', (e) => {
        e.stopPropagation();
        const value = e.target.getAttribute('data-value');
        
        if (value === 'all') {
          selectedTags = [];
          updateFilterDisplay();
          filterGallery([]);
        } else {
          if (selectedTags.includes(value)) {
            selectedTags = selectedTags.filter(tag => tag !== value);
          } else {
            selectedTags.push(value);
          }
          updateFilterDisplay();
          filterGallery(selectedTags);
        }
        
        // Keep dropdown open for multiple selections
        // Don't close dropdown automatically
      });
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!filterTags.contains(e.target) && !filterDropdown.contains(e.target)) {
        filterDropdown.classList.remove('open');
      }
    });
    
    // Add change handler to sort select
    const sortSelect = document.getElementById('sort-select');
    if (sortSelect) {
      sortSelect.addEventListener('change', (e) => {
        sortGallery(e.target.value);
      });
    }
    
    // Add click handlers to gallery images (delegated event)
    const gallery = document.getElementById('gallery');
    gallery.addEventListener('click', (e) => {
      if (e.target.tagName === 'IMG') {
        const img = e.target;
        const src = img.getAttribute('data-src') || img.getAttribute('src');
        const alt = img.getAttribute('data-alt') || img.getAttribute('alt');
        const title = img.getAttribute('data-title') || img.getAttribute('title');
        
        openImageModal(src, alt, title);
      }
    });
    
    // Image modal functionality
    const imageModal = document.getElementById('image-modal');
    const imageModalImg = document.getElementById('image-modal-img');
    const imageModalClose = document.getElementById('image-modal-close');
    const imageModalOverlay = document.getElementById('image-modal-overlay');
    
    // Close modal button
    if (imageModalClose) {
      imageModalClose.addEventListener('click', closeImageModal);
    }
    
    // Close modal when clicking overlay or outside image
    if (imageModal) {
      imageModal.addEventListener('click', (e) => {
        // Close if clicking on the modal background (not on the image or close button)
        if (e.target === imageModal || e.target === imageModalOverlay) {
          closeImageModal();
        }
      });
    }
    
    // Close modal with escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && imageModal && imageModal.classList.contains('open')) {
        closeImageModal();
      }
    });
    
    // Handle window resize to re-initialize masonry layout
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => initMasonryLayout(), 250);
    });
  });
  
  function openImageModal(src, alt, title) {
    const imageModal = document.getElementById('image-modal');
    const imageModalImg = document.getElementById('image-modal-img');
    
    if (imageModal && imageModalImg) {
      imageModalImg.src = src;
      imageModalImg.alt = alt || title || '';
      imageModal.classList.add('open');
      document.body.style.overflow = 'hidden';
    }
  }
  
  function closeImageModal() {
    const imageModal = document.getElementById('image-modal');
    
    if (imageModal) {
      imageModal.classList.remove('open');
      document.body.style.overflow = '';
    }
  }
  
  // Update filter display
  function updateFilterDisplay() {
    const filterTags = document.getElementById('filter-tags');
    const placeholder = filterTags.querySelector('.filter-placeholder');
    const filterOptions = document.querySelectorAll('.filter-option');
    
    // Update dropdown options to show selected state
    filterOptions.forEach(option => {
      const value = option.getAttribute('data-value');
      if (selectedTags.includes(value)) {
        option.classList.add('selected');
      } else {
        option.classList.remove('selected');
      }
    });
    
    if (selectedTags.length === 0) {
      if (placeholder) {
        placeholder.style.display = 'block';
      }
      // Remove existing tag elements
      const existingTags = filterTags.querySelectorAll('.selected-tag');
      existingTags.forEach(tag => tag.remove());
    } else {
      if (placeholder) {
        placeholder.style.display = 'none';
      }
      
      // Remove existing tag elements
      const existingTags = filterTags.querySelectorAll('.selected-tag');
      existingTags.forEach(tag => tag.remove());
      
      // Add selected tags
      selectedTags.forEach(tag => {
        const tagElement = document.createElement('span');
        tagElement.className = 'selected-tag';
        tagElement.innerHTML = `${tag} <button class="remove-tag" data-tag="${tag}">Ã—</button>`;
        filterTags.appendChild(tagElement);
        
        // Add remove functionality
        const removeBtn = tagElement.querySelector('.remove-tag');
        removeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const tagToRemove = e.target.getAttribute('data-tag');
          selectedTags = selectedTags.filter(t => t !== tagToRemove);
          updateFilterDisplay();
          filterGallery(selectedTags);
        });
      });
    }
  }
  
  // Make openImageModal globally available for backwards compatibility
  (window as any).openImageModal = openImageModal;
</script>