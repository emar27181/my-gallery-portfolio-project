---
import { images } from '../data/image';
const breakpointCols = { default: 4, 1024: 3, 768: 2, 640: 2 };

// Get unique tags from all images
const allTags = [...new Set(images.flatMap(image => image.tags))];
---

<div class="gallery-container">

  <!-- üè∑Ô∏è „Éï„Ç£„É´„Çø„Éº & „ÇΩ„Éº„Éà -->
  <div class="controls-container">
    <div class="filter-container">
      <label for="filter-select" class="filter-label">„Éï„Ç£„É´„Çø:</label>
      <select id="filter-select" class="filter-select">
        <option value="all">ÂÖ®„Å¶</option>
        {allTags.map(tag => (
          <option value={tag}>{tag}</option>
        ))}
      </select>
    </div>
    
    <div class="sort-container">
      <label for="sort-select" class="sort-label">‰∏¶„Å≥È†Ü:</label>
      <select id="sort-select" class="sort-select">
        <option value="date-desc">Êó•‰ªò (Êñ∞„Åó„ÅÑÈ†Ü)</option>
        <option value="date-asc">Êó•‰ªò (Âè§„ÅÑÈ†Ü)</option>
        <option value="title-asc">„Çø„Ç§„Éà„É´ („ÅÇ-„Çì)</option>
        <option value="title-desc">„Çø„Ç§„Éà„É´ („Çì-„ÅÇ)</option>
        <option value="category">„Ç´„ÉÜ„Ç¥„É™</option>
      </select>
    </div>
  </div>

  <!-- üñº „ÇÆ„É£„É©„É™„Éº -->
  <div id="gallery">
    <div class="masonry-container" id="masonry-container">
      {
        images.map(({ src, alt, title, tags, date }) => (
          <div class="masonry-item" data-tags={tags.join(',')} data-title={title} data-date={date} data-category={tags[0]}>
            <img
              src={src}
              alt={alt}
              title={title}
              loading="lazy"
              data-src={src}
              data-alt={alt}
              data-title={title}
            />
          </div>
        ))
      }
    </div>
  </div>
</div>

<!-- Image Modal -->
<div class="image-modal" id="image-modal">
  <div class="image-modal-overlay" id="image-modal-overlay">
    <div class="image-modal-content">
      <img class="image-modal-img" id="image-modal-img" src="" alt="" />
      <button class="image-modal-close" id="image-modal-close" aria-label="Close image">
        <svg fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
        </svg>
      </button>
    </div>
  </div>
</div>

<script>
  let currentFilter = 'all';
  let currentSort = 'date-desc';
  
  function sortGallery(sortBy) {
    const masonryContainer = document.getElementById('masonry-container');
    const items = Array.from(document.querySelectorAll('.masonry-item'));
    
    items.sort((a, b) => {
      switch (sortBy) {
        case 'date-desc':
          return new Date(b.getAttribute('data-date')) - new Date(a.getAttribute('data-date'));
        case 'date-asc':
          return new Date(a.getAttribute('data-date')) - new Date(b.getAttribute('data-date'));
        case 'title-asc':
          return a.getAttribute('data-title').localeCompare(b.getAttribute('data-title'));
        case 'title-desc':
          return b.getAttribute('data-title').localeCompare(a.getAttribute('data-title'));
        case 'category':
          const categoryA = a.getAttribute('data-category');
          const categoryB = b.getAttribute('data-category');
          if (categoryA === categoryB) {
            // Secondary sort by date if categories are the same
            return new Date(b.getAttribute('data-date')) - new Date(a.getAttribute('data-date'));
          }
          return categoryA.localeCompare(categoryB);
        default:
          return 0;
      }
    });
    
    // Clear container and re-append sorted items
    masonryContainer.innerHTML = '';
    items.forEach(item => {
      masonryContainer.appendChild(item);
    });
    
    currentSort = sortBy;
    
    // Re-apply current filter after sorting
    filterGallery(currentFilter);
  }
  
  function filterGallery(selectedTag) {
    const masonryItems = document.querySelectorAll('.masonry-item');
    
    masonryItems.forEach(item => {
      const itemTags = item.getAttribute('data-tags').split(',');
      
      if (selectedTag === 'all' || itemTags.includes(selectedTag)) {
        item.style.display = 'block';
      } else {
        item.style.display = 'none';
      }
    });
    
    currentFilter = selectedTag;
  }
  
  document.addEventListener('DOMContentLoaded', () => {
    // Initialize with default sort
    sortGallery(currentSort);
    
    // Add change handler to filter select
    const filterSelect = document.getElementById('filter-select');
    if (filterSelect) {
      filterSelect.addEventListener('change', (e) => {
        filterGallery(e.target.value);
      });
    }
    
    // Add change handler to sort select
    const sortSelect = document.getElementById('sort-select');
    if (sortSelect) {
      sortSelect.addEventListener('change', (e) => {
        sortGallery(e.target.value);
      });
    }
    
    // Add click handlers to gallery images
    const galleryImages = document.querySelectorAll('#gallery img');
    galleryImages.forEach((img) => {
      img.addEventListener('click', () => {
        const src = img.getAttribute('data-src') || img.getAttribute('src');
        const alt = img.getAttribute('data-alt') || img.getAttribute('alt');
        const title = img.getAttribute('data-title') || img.getAttribute('title');
        
        openImageModal(src, alt, title);
      });
    });
    
    // Image modal functionality
    const imageModal = document.getElementById('image-modal');
    const imageModalImg = document.getElementById('image-modal-img');
    const imageModalClose = document.getElementById('image-modal-close');
    const imageModalOverlay = document.getElementById('image-modal-overlay');
    
    // Close modal button
    if (imageModalClose) {
      imageModalClose.addEventListener('click', closeImageModal);
    }
    
    // Close modal when clicking overlay or outside image
    if (imageModal) {
      imageModal.addEventListener('click', (e) => {
        // Close if clicking on the modal background (not on the image or close button)
        if (e.target === imageModal || e.target === imageModalOverlay) {
          closeImageModal();
        }
      });
    }
    
    // Close modal with escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && imageModal && imageModal.classList.contains('open')) {
        closeImageModal();
      }
    });
  });
  
  function openImageModal(src, alt, title) {
    const imageModal = document.getElementById('image-modal');
    const imageModalImg = document.getElementById('image-modal-img');
    
    if (imageModal && imageModalImg) {
      imageModalImg.src = src;
      imageModalImg.alt = alt || title || '';
      imageModal.classList.add('open');
      document.body.style.overflow = 'hidden';
    }
  }
  
  function closeImageModal() {
    const imageModal = document.getElementById('image-modal');
    
    if (imageModal) {
      imageModal.classList.remove('open');
      document.body.style.overflow = '';
    }
  }
  
  // Make openImageModal globally available for backwards compatibility
  (window as any).openImageModal = openImageModal;
</script>